Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Временная сложность: O(n + k) в среднем, O(n²) в худшем случае
Почему возникает:
Создание корзин и распределение элементов: O(n)
Сортировка каждой корзины: зависит от алгоритма сортировки внутри корзин
В худшем случае, когда все элементы попадают в одну корзину, получаем O(n²)
В худшем случае, когда все элементы попадают в одно ведро, получаем O(n²)

Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов).
buckets = [[] for _ in range(len(arr))]
2. Каждый элемент помещается в корзину согласно функции распределения.
for val in arr:
    index = int(val * len(arr))
    buckets[index].append(val)
3. Содержимое каждой корзины сортируется индивидуально.
for bucket in buckets:
    bucket.sort()
4. Корзины соединяются в порядке увеличения диапазона.
result = []
for bucket in buckets:
    result.extend(bucket)
return result
<img width="475" height="595" alt="image" src="https://github.com/user-attachments/assets/ed7c07a7-7d33-4d24-a9fe-46f97be23a71" />
Особенности:
Эффективна для равномерно распределённых числовых данных и может достигать линейной
асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает
при неравномерном распределении данных.
############################################################################################################################################################################################################################
Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.

Временная сложность: O(n²)
Почему возникает:
Внешний цикл выполняется n раз
На каждой итерации ищем максимум в подмассиве: O(n)
Выполняем два переворота массива: O(n) каждый
Итого: O(n × n) = O(n²)

Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива.
max_idx = arr.index(max(arr[:size]))
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот
элемент оказался первым.
flip(arr, max_idx + 1)
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
flip(arr, size)
4. Повторить процесс для оставшейся неотсортированной части массива.
for size in range(n, 1, -1)
<img width="464" height="574" alt="image" src="https://github.com/user-attachments/assets/135b1a29-f2df-47e0-97d6-33e7cac8a996" />
Особенности:
Сложность алгоритма — O(n2). Он интересен теоретически и используется как пример
нестандартных методов сортировки.
############################################################################################################################################################################################################################
Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.

Временная сложность: O(S) где S - сумма всех элементов
Почему возникает:
Каждая "бусинка" обрабатывается отдельно
S = сумма всех чисел в массиве

Принцип работы:
Время пропорционально общему количеству "бусинок"
1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению.
beads = [[0] * max(arr) for _ in range(len(arr))]
for i, val in enumerate(arr):
    for j in range(val):
        beads[i][j] = 1
2. Бусины располагаются на «стержнях» (как на абаке).
beads = [[0] * max(arr) for _ in range(len(arr))]
3. Под действием «гравитации» бусины падают вниз.
for j in range(max(arr)):
    sum_ = sum(beads[i][j] for i in range(len(arr)))
    for i in range(len(arr) - 1, len(arr) - sum_ - 1, -1):
        beads[i][j] = 1
    for i in range(len(arr) - sum_ - 1, -1, -1):
        beads[i][j] = 0
4. После оседания бусин строки считываются сверху вниз — получается
отсортированный массив.
return [row.count(i) for row in beads]
<img width="503" height="523" alt="image" src="https://github.com/user-attachments/assets/1657ef74-a693-4d87-a42b-2957529275a5" />
Особенности:
Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность —
O(n), но практическая — выше из-за ограничения на диапазон и реализацию.
############################################################################################################################################################################################################################
Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.

Временная сложность: O(√n)

Почему возникает:
Делаем скачки размером √n пока не найдем нужный диапазон
Затем линейный поиск в блоке размером √n
Итого: O(√n + √n) = O(√n)

Принцип работы:
1. Делится массив на блоки длины m=n.
step = int(math.sqrt(n))
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому.
while arr[min(step, n) - 1] < x:
    prev = step
    step += int(math.sqrt(n))
    if prev >= n:
        return -1
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке.
while arr[prev] < x:
    prev += 1
    if prev == min(step, n):
        return -1
if arr[prev] == x:
    return prev
return -1
<img width="478" height="581" alt="image" src="https://github.com/user-attachments/assets/4632a276-88b3-47d3-9d55-9bd3e67aafc1" />
Особенности:
В среднем сложность поиска O(n).
Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное
время.
############################################################################################################################################################################################################################
Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

Временная сложность: O(log n)
Почему возникает:
Экспоненциально увеличиваем диапазон поиска: O(log i) где i - позиция элемента
Затем бинарный поиск в найденном диапазоне: O(log n)
Итого: O(log n)

Принцип работы:
1. Проверяется первый элемент массива.
if arr[0] == x:
    return 0
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.
i = 1
n = len(arr)
while i < n and arr[i] <= x:
    i += 2
3. На найденном диапазоне выполняется бинарный поиск.
low = i // 2
high = min(i, n-1)
while low <= high:
    mid = (low + high) // 2
    if arr[mid] == x:
        return mid
    elif arr[mid] < x:
        low = mid + 1
    else:
        high = mid - 1
return -1
<img width="409" height="505" alt="image" src="https://github.com/user-attachments/assets/53070e20-bb08-4f3c-b6a6-75c8273af591" />
Особенности:
Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с
неизвестным размером или частичным доступом.
############################################################################################################################################################################################################################
Тернарный поиск (Ternary Search)
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).

Временная сложность: O(log₃n)
Почему возникает:
На каждом шаге делим массив на 3 части
Отбрасываем 2/3 массива на каждой итерации
Количество итераций: log₃n

Принцип работы (для массива):
1. Делится диапазон индексов на три части.
mid1 = l + (r - 1) // 3
mid2 = r - (r - 1) // 3
2. Сравнивается искомый элемент с элементами на двух разделительных границах.
if arr[mid1] == x:
    return mid1
if arr[mid2] == x:
    return mid2
3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети
массива, где может находиться искомое значение.
if x < arr[mid1]:
    return ternary_search(arr, l, mid1 - 1, x)
elif x > arr[mid2]:
    return ternary_search(arr, mid2 + 1, r, x)
else:
    return ternary_search(arr, mid1 + 1, mid2 - 1, x)
<img width="409" height="504" alt="image" src="https://github.com/user-attachments/assets/17a04f18-8aa2-400e-9495-8f11eb464ec6" />
Особенности:
Сложность также O(log⁡n), но число сравнений на шаг выше, чем в двоичном поиске.
Помимо массивов, тернарный поиск часто используется для нахождения минимума или
максимума на унимодальных функциях.



