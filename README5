Вариант 12. Создайте функцию для генерации всех сочетаний размера k из n элементов(комбинаторные задачи).
Анализ алгоритма генерации комбинаций(для кода на python)
Назначение кода
Данный код генерирует все возможные комбинации из n элементов, взятых по k элементов. Комбинации представляют собой наборы чисел от 1 до n длиной k, где порядок элементов не имеет значения.

Как работает код
Основные компоненты:
get_combinations(n, k) - основная функция, возвращающая список всех комбинаций
backtrack(start, combo) - рекурсивная функция backtracking (поиск с возвратом)
res - список для хранения результатов
combo - текущая формируемая комбинация

Пошаговый алгоритм:
Инициализация: Создается пустой список res для хранения результатов

Запуск backtracking: Вызывается backtrack(1, []) с начальным числом 1 и пустой комбинацией

Базовый случай: Если длина combo равна k, комбинация добавляется в res и функция возвращается

Рекурсивный случай: Для каждого числа от start до n:
Добавляем число в текущую комбинацию

Рекурсивно вызываем backtrack с увеличенным начальным значением

Удаляем последний элемент (backtrack)

Временная сложность
Формула количества комбинаций:
C(n, k) = n! / (k! × (n-k)!)

Анализ сложности:
Верхняя оценка: O(C(n,k) × k)

Факторизация:
Генерируется C(n,k) комбинаций

Каждая комбинация требует O(k) операций (добавление/удаление элементов)

Практическая оценка: O(n! / (k! × (n-k)!)) × k
Пространственная сложность
Память результатов: O(C(n,k) × k) для хранения всех комбинаций

Рекурсивный стек: O(k) - глубина рекурсии равна k
Общая: O(C(n,k) × k + k) = O(C(n,k) × k)

Ключевые особенности
Backtracking паттерн: Классический подход "попробовать-откатиться"

Избегание дубликатов: Использование start параметра гарантирует, что числа в комбинации идут в возрастающем порядке

Эффективность: Алгоритм генерирует только валидные комбинации, пропуская заведомо невалидные пути

Ответ на вопрос:
10. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?
Обход в направлении (DFS) исследует дерево или граф, двигаясь как можно глубже по одному пути, пока не достигнет конца, а затем возвращается назад, чтобы исследовать другие ветви. Для этого используется структура данных стек или рекурсия. Обход в повороте (BFS) посещает все узлы на один уровень раньше, чем перейти к следующему, поочередно. BFS гарантирует нахождение кратчайшего пути в терминах количества шагов, тогда как DFS этого не гарантирует. DFS обычно требует меньше памяти, а BFS — больше, поскольку хранит все современные современные уровни. DFS может войти в бесконечный цикл при обходе графа без контроля, BFS этого избегает. В целом, DFS подходит для полного исследования всех путей, а BFS — для поиска кратчайшего пути и изучения уровней структуры.
