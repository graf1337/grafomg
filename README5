Вариант 12. Создайте функцию для генерации всех сочетаний размера k из n элементов(комбинаторные задачи).
Анализ алгоритма генерации комбинаций(для кода на python)
Назначение кода
Данный код генерирует все возможные комбинации из n элементов, взятых по k элементов. Комбинации представляют собой наборы чисел от 1 до n длиной k, где порядок элементов не имеет значения.

Как работает код
Основные компоненты:
get_combinations(n, k) - основная функция, возвращающая список всех комбинаций
backtrack(start, combo) - рекурсивная функция backtracking (поиск с возвратом)
res - список для хранения результатов
combo - текущая формируемая комбинация

Пошаговый алгоритм:
Инициализация: Создается пустой список res для хранения результатов
Запуск backtracking: Вызывается backtrack(1, []) с начальным числом 1 и пустой комбинацией
Базовый случай: Если длина combo равна k, комбинация добавляется в res и функция возвращается
Рекурсивный случай: Для каждого числа от start до n:
Добавляем число в текущую комбинацию
Рекурсивно вызываем backtrack с увеличенным начальным значением
Удаляем последний элемент (backtrack)

Временная сложность
Формула количества комбинаций:
C(n, k) = n! / (k! × (n-k)!)

1. Количество комбинаций (C(n, k))

Алгоритм генерирует все возможные комбинации из n элементов по k

Количество таких комбинаций вычисляется биномиальным коэффициентом: C(n, k) = n!/(k!(n-k)!)

В худшем случае (при k = n/2) это примерно O(2ⁿ/√n)

2. Стоимость создания каждой комбинации (O(k))

Когда мы находим валидную комбинацию (len(combo) == k), мы делаем res.append(combo.copy())

Операция combo.copy() создает копию списка размером k, что стоит O(k)

Это происходит для каждой найденной комбинации

3. Общая сложность

У нас есть C(n, k) комбинаций

Для каждой комбинации мы тратим O(k) на создание копии

Итого: O(k × C(n, k))

Ответ на вопрос:
10. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?
Обход в направлении (DFS) исследует дерево или граф, двигаясь как можно глубже по одному пути, пока не достигнет конца, а затем возвращается назад, чтобы исследовать другие ветви. Для этого используется структура данных стек или рекурсия. Обход в повороте (BFS) посещает все узлы на один уровень раньше, чем перейти к следующему, поочередно. BFS гарантирует нахождение кратчайшего пути в терминах количества шагов, тогда как DFS этого не гарантирует. DFS обычно требует меньше памяти, а BFS — больше, поскольку хранит все современные современные уровни. DFS может войти в бесконечный цикл при обходе графа без контроля, BFS этого избегает. В целом, DFS подходит для полного исследования всех путей, а BFS — для поиска кратчайшего пути и изучения уровней структуры.
