Анализ жадного алгоритма для задачи MAX CUT
1. Определение алгоритма
Жадный алгоритм локального поиска для задачи MAX CUT — это итеративный алгоритм, который начинает с произвольного разбиения вершин на две группы и последовательно улучшает решение, перемещая вершины между группами если это увеличивает количество рёбер в разрезе. Алгоритм завершается когда ни одно перемещение вершины не приводит к улучшению.

Принцип работы: На каждой итерации алгоритм проверяет каждую вершину — если перемещение вершины в противоположную группу увеличивает количество рёбер разреза, вершина перемещается. Процесс повторяется до достижения локального оптимума.

2. Анализ алгоритма
Принцип работы алгоритма (по шагам)

Инициализация разбиения
Строка: groupA = set([0]); groupB = set(range(1, n))
Суть: создаётся начальное разбиение — вершина 0 помещается в группу A, все остальные вершины в группу B.
Зачем: требуется начальное решение для последующего улучшения.

Итеративное улучшение
Цикл: while improved:
Суть: алгоритм продолжает работать до тех пор, пока на очередной итерации было выполнено хотя бы одно улучшающее перемещение.
Зачем: гарантирует, что будет найден локальный оптимум.

Проверка вершин
Цикл: for v in range(n):
Суть: на каждой итерации внешнего цикла проверяются все вершины графа.
Зачем: обеспечивает рассмотрение всех возможных кандидатов на перемещение.

Оценка перемещения
Операция: вычисление cut_before и cut_after
Суть: для каждой вершины вычисляется количество рёбер разреза до и после потенциального перемещения.
Зачем: определяет, приведёт ли перемещение вершины к улучшению решения.

Принятие решения о перемещении
Условие: if cut_after > cut_before:
Суть: если перемещение увеличивает количество рёбер в разрезе, оно сохраняется, иначе откатывается.
Зачем: гарантирует монотонное улучшение решения на каждом шаге.

3. Оценка временной сложности
Итоговая временная сложность: O(n² × m)

4. Обоснование оценки временной сложности
Обоснование по шагам:

Внешний цикл while
Операция: while improved:
Сложность: O(n) итераций в худшем случае
Почему: в худшем случае на каждой итерации может перемещаться одна вершина, и всего вершин n

Внутренний цикл for
Операция: for v in range(n):
Сложность: O(n) итераций на каждую итерацию внешнего цикла
Почему: перебираются все n вершин графа

Вычисление cut_before и cut_after
Операция: sum(((v in groupA) != (u in groupA)) for u, w in edges if v==u or v==w)
Сложность: O(m) для каждой вершины
Почему: для каждой вершины выполняется перебор всех m рёбер для поиска инцидентных

Операции с множествами
Операция: groupA.add/remove, groupB.add/remove
Сложность: O(1) в среднем случае
Почему: операции с set в Python имеют константную сложность в среднем

Итоговая сложность:
O(n) × O(n) × O(m) = O(n² × m)

Доминирование: вычисление cut_before и cut_after (O(m)) выполняется для каждой вершины (O(n)) на каждой итерации улучшения (O(n)), поэтому общая сложность определяется произведением этих трёх факторов.

5. Ответ на контрольный вопрос
Контрольный вопрос №9. Жадный алгоритм для покрытия множеств. Какой коэффициент аппроксимации имеет жадный алгоритм для задачи о покрытии множеств и почему?

Жадный алгоритм для задачи о покрытии множеств имеет коэффициент аппроксимации H(d), где d — размер наибольшего множества в системе, а H(k) = ∑(i=1 to k) 1/i — k-е гармоническое число.

Доказательство аппроксимации H(d):

Алгоритм:

На каждом шаге выбираем множество, покрывающее наибольшее количество ещё непокрытых элементов

Добавляем это множество в покрытие

Удаляем покрытые элементы из рассмотрения

Повторяем до покрытия всех элементов

Доказательство:

Обозначения:

OPT — стоимость оптимального покрытия

k-й непокрытый элемент покрывается, когда осталось не менее n/k непокрытых элементов

Каждое множество в оптимальном покрытии стоит 1, но его стоимость "распределяется" по элементам

Распределение стоимости:
Когда алгоритм выбирает множество S по цене c(S) = 1, стоимость распределяется равномерно между вновь покрытыми элементами. Если S покрывает t новых элементов, каждый получает стоимость 1/t.

Анализ для отдельного элемента e:
Рассмотрим момент, когда элемент e покрывается. В этот момент:

Существует непокрытое множество в оптимальном решении, содержащее e

Это множество покрывает хотя бы n/k непокрытых элементов (где k — количество ещё непокрытых элементов)

По жадному выбору, цена за покрытие e не превышает 1/(n/k) = k/n

Суммарная стоимость:
Суммируя по всем элементам в порядке покрытия:
∑(стоимость элемента e) ≤ ∑(k=1 to n) 1/k = H(n) ≤ H(d)

Поскольку каждый элемент оптимального покрытия имеет стоимость 1 в оптимальном решении, а наш алгоритм даёт стоимость не более H(d) · OPT, получаем коэффициент аппроксимации H(d).

Для d элементов H(d) ≈ ln d + O(1), что делает этот алгоритм логарифмической аппроксимацией.
