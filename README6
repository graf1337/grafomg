Сортировка выбором (Selection Sort)
Определение:
Сортировка выбором (Selection Sort) — это один из наиболее простых алгоритмов сортировки, который основан на последовательном поиске минимального (или максимального) значения и его перемещении в начало упорядоченной части. Принцип работы заключается в том, что в каждом цикле алгоритм выбирает самый подходящий элемент из ещё неотсортированной области массива и помещает его туда, где он должен находиться в финальном, отсортированном состоянии.

Алгоритм:

Рассматриваем первый элемент массива как минимум.

Последовательно проверяем все оставшиеся элементы, чтобы найти действительно минимальный.

Если найден элемент меньше текущего минимума — запоминаем его индекс.

По окончании внутреннего цикла меняем местами текущий и минимальный элемент.

Увеличиваем индекс и повторяем действия до конца массива.

В результате после каждой итерации один элемент оказывается на своём месте, а массив постепенно перестраивается в возрастающем порядке.

Временная сложность: O(n²)
Сложность обусловлена тем, что для каждого элемента массива в худшем случае нужно сравнить его со всеми оставшимися, то есть выполняется сумма сравнений 1+2+3+…+(n−1), что эквивалентно O(n²).

Сортировка пузырьком (Bubble Sort)
Определение:
Сортировка обменом, или пузырьковая сортировка (Bubble Sort), — базовый метод, в котором элементы массива многократно сравниваются попарно и при необходимости меняются местами. После каждой итерации самый крупный элемент «всплывает» к концу, как пузырёк воды, и больше не участвует в последующих сравнениях.

Алгоритм:

Сравниваем пары соседних элементов.

Если левый элемент больше правого — выполняется их обмен.

Проходим по всему массиву, постепенно перемещая крупные элементы в конец.

После одного полного прохода последний элемент оказывается на нужной позиции, и количество сравнений уменьшается.

Повторяем процесс, пока весь массив не станет отсортированным.

Временная сложность: O(n²)
На каждом шаге требуется множество попарных сравнений. В среднем выполняется около n×(n−1)/2 сравнений, что и даёт квадратичную сложность.

Сортировка вставками (Insertion Sort)
Определение:
Сортировка вставками (Insertion Sort) — метод, который имитирует процесс упорядочивания карт в руке: каждый новый элемент вставляется в правильное место среди уже отсортированной части.

Алгоритм:

Начинаем с второго элемента и считаем первый уже отсортированным.

Сравниваем текущий элемент с предыдущими.

Все большие элементы сдвигаются на одну позицию вправо, освобождая место для текущего.

После каждой итерации часть массива слева полностью упорядочена.
К концу прохода через массив элементы «вставляются» на свои места, формируя отсортированную последовательность.

Временная сложность: O(n²)
При обратном порядке элементов алгоритм вынужден сдвигать каждый элемент на каждое сравнение, что создаёт 1+2+3+…+(n−1) операций — типичную квадратичную зависимость.

Сортировка слиянием (Merge Sort)
Определение:
Сортировка слиянием (Merge Sort) — это эффективный алгоритм, реализующий стратегию «разделяй и властвуй». Он делит исходный массив пополам до получения отдельных элементов, а затем последовательно объединяет их в более крупные отсортированные массивы.

Алгоритм:

Делим массив на две равные части.

Рекурсивно повторяем разделение, пока каждая часть не станет состоять из одного элемента.

Начинается этап слияния — сопоставляем два отсортированных подмассива, выбирая наименьший элемент из их начал и добавляя в результирующий массив.

Процесс продолжается, пока все элементы не объединятся.

Сортировка слиянием стабильно работает и на больших массивах, не зависит от исходного порядка данных.

Временная сложность: O(n log n)
Каждый уровень рекурсии обрабатывает n элементов, а глубина деления массива составляет log n, поэтому общая сложность O(n log n).

Сортировка Шелла (Shell Sort)
Определение:
Сортировка Шелла (Shell Sort) — улучшенный вариант сортировки вставками, где сначала обрабатываются элементы, стоящие на расстоянии друг от друга. По мере выполнения алгоритма этот «шаг» (gap) уменьшается, и данные становятся всё более упорядоченными.

Алгоритм:

Устанавливаем начальное значение gap = n / 2.

Сравниваем элементы, находящиеся на расстоянии gap друг от друга, и выполняем перестановку при нарушении порядка.

После каждого прохода уменьшаем gap вдвое и повторяем те же действия.

Когда gap равен 1, выполняется финальная сортировка вставками.

Элементы постепенно «подтягиваются» ближе к своим позициям, что ускоряет окончательную сортировку.

Временная сложность: O(n²)
В худшем случае сохраняется квадратичная зависимость, так как внутри цикла сравниваются и переставляются почти все элементы массива.

Быстрая сортировка (Quick Sort)
Определение:
Быстрая сортировка (Quick Sort) использует разделение массива вокруг опорного элемента (pivot). Элементы, меньшие pivot, помещаются слева, а большие — справа. Рекурсия повторяется, пока не останется по одному элементу.

Алгоритм:

Выбирается pivot (часто — средний элемент).

Делим массив на три части: элементы меньше pivot, равные ему и больше.

Рекурсивно применяем сортировку к левому и правому подмассивам.

Объединяем результаты в итоговую упорядоченную последовательность.

Временная сложность: O(n²)
В среднем алгоритм работает за O(n log n), но при неудачном выборе pivot (например, при уже отсортированном массиве) получает худший случай — O(n²).

Пирамидальная сортировка (Heap Sort)
Определение:
Пирамидальная сортировка (Heap Sort) основана на структуре данных «двоичная куча» (binary heap), которая обеспечивает быстрый доступ к наибольшему или наименьшему элементу.

Алгоритм:

Сначала из массива создаётся max‑heap — полная бинарная куча.

На каждом шаге извлекается корневой элемент (максимум) и ставится в конец массива.

После удаления вершины структура кучи восстанавливается вызовом heapify.

Повторяем процесс до тех пор, пока в куче не останется один элемент.

После завершения всех шагов массив полностью отсортирован.

Временная сложность: O(n log n)
Каждое извлечение требует O(log n) операций, а всего таких извлечений n, что даёт O(n log n).

Линейный поиск (Linear Search)
Определение:
Линейный поиск — это базовый метод поиска, при котором программа проверяет каждый элемент по очереди. Алгоритм не требует, чтобы массив был отсортирован, и подходит даже для неупорядоченных данных.

Алгоритм:

Перебираем элементы массива с начала.

Сравниваем каждый элемент с искомым значением.

Если найдено совпадение — возвращается индекс элемента.

Если достигнут конец массива без совпадений — возвращается −1.

Временная сложность: O(n)
Количество сравнений пропорционально числу элементов. В худшем случае нужно пройти весь массив.

Бинарный поиск (Binary Search)
Определение:
Бинарный поиск — метод поиска элемента в отсортированном массиве, который многократно делит диапазон пополам, минимизируя число сравнений.

Алгоритм:

Находим середину массива и сравниваем её с искомым значением.

Если совпадает — элемент найден.

Если искомое значение меньше, поиск продолжается в левой части; если больше — в правой.

Процесс повторяется, пока интервал не станет пустым.

Временная сложность: O(log n)
Потому что при каждом шаге область поиска сокращается вдвое, уменьшая количество необходимых проверок.

Интерполирующий поиск (Interpolation Search)
Определение:
Интерполяционный поиск — это модификация бинарного поиска, которая использует значение искомого элемента для оценки его возможной позиции в массиве.

Алгоритм:

Устанавливаем границы low и high.

Приблизительно вычисляем позицию pos по формуле интерполяции.

Сравниваем элемент с искомым: если меньше — сдвигаем границу low, если больше — уменьшаем high.

Повторяем шаги, пока диапазон не сузится до нуля или элемент не будет найден.

Временная сложность: O(n)
В случае неравномерного распределения данных поиск теряет эффективность и сводится к последовательному перебору.

Поиск по Фибоначчи (Fibonacci Search)
Определение:
Поиск Фибоначчи — это вариант бинарного поиска, где разделение массива происходит не пополам, а в пропорции, заданной числами Фибоначчи.

Алгоритм:

Определяются последовательные числа Фибоначчи, чтобы покрыть длину массива.

Элементы сравниваются с позицией, вычисленной на основе этих чисел.

В зависимости от результата поиск продолжается в одной из частей массива.

Процесс идёт, пока не найден элемент или не останется одна позиция.

Временная сложность: O(log n)
Каждый шаг уменьшает размер области поиска в соответствии с числовым рядом Фибоначчи, давая логарифмическое увеличение числа шагов при росте массива.
